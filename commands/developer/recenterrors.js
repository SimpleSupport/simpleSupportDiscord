const {
    SlashCommandBuilder
} = require("@discordjs/builders");
const Discord = require('discord.js');
const { MessageActionRow, MessageButton, MessageEmbed } = require('discord.js');
const errorDatabase = require('../../models/errorLog');

module.exports = {
    category: "developers",
    data: new SlashCommandBuilder()
        .setName('show-errors')
        .setDescription(`Displays recent errors including the ID.`),
    async execute(interaction, client) {
        if(!interaction.member.id === "351189462891626496") {
            const embed = new Discord.MessageEmbed()
            .setDescription('**Insufficient Permissions**\nThis command is restricted to developers for privacy reasons.')
            .setColor('RED')
            interaction.reply({embeds: [embed], emphemeral: true});
            return;
        }

        const errors = await errorDatabase.findAll()
        await interaction.deferReply();
// Constants

const backId = 'back'
const forwardId = 'forward'
const backButton = new MessageButton({
    style: 'DANGER',
    label: '←',
    customId: backId
})
const forwardButton = new MessageButton({
    style: 'DANGER',
    label: '→',
    customId: forwardId
})

// Put the following code wherever you want to send the embed pages:

/**
 * Creates an embed with guilds starting from an index.
 * @param {number} start The index to start from.
 * @returns {Promise<MessageEmbed>}
 */
const generateEmbed = async start => {
    const current = errors.slice(start, start + 5)

    // You can of course customise this embed however you want
    return new MessageEmbed({
        title: `Showing Errors ${start + 1}-${start + current.length} out of ${
      errors.length
    }`,
        color: 'ff5e5e',
        footer: `Generated by ${interaction.author}`,
        fields: await Promise.all(
            current.map(async error => ({
                name: error.dataValues.id,
                value: `**Error:** \`\`${error.error}\`\`\n**Command:** \`\`/${error.dataValues.command}\`\``
            }))
        )
    })
}

// Send the embed with the first 10 guilds
const canFitOnOnePage = errors.length <= 5
const embedMessage = await interaction.editReply({
    embeds: [await generateEmbed(0)],
    components: canFitOnOnePage ?
        [] :
        [new MessageActionRow({
            components: [forwardButton]
        })]
})
// Exit if there is only one page of guilds (no need for all of this)
if (canFitOnOnePage) return

// Collect button interactions (when a user clicks a button),
// but only when the button as clicked by the original message author
const collector = embedMessage.createMessageComponentCollector({
    filter: ({
        user
    }) => user.id === interaction.user.id
})

let currentIndex = 0
collector.on('collect', async interaction => {
    // Increase/decrease index
    interaction.customId === backId ? (currentIndex -= 5) : (currentIndex += 5)
    // Respond to interaction by updating message with new embed
    await interaction.update({
        embeds: [await generateEmbed(currentIndex)],
        components: [
            new MessageActionRow({
                components: [
                    // back button if it isn't the start
                    ...(currentIndex ? [backButton] : []),
                    // forward button if it isn't the end
                    ...(currentIndex + 5 < errors.length ? [forwardButton] : [])
                ]
            })
        ]
    })
})


    }
}